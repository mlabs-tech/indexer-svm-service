import { PublicKey } from '@solana/web3.js';
import config from '../config';

const PROGRAM_ID = new PublicKey(config.programId);

// Instruction discriminators from cryptarena_svm_test IDL
// These are the actual 8-byte discriminators generated by Anchor
export const INSTRUCTION_DISCRIMINATORS: Record<string, Buffer> = {
  initialize: Buffer.from([175, 175, 109, 31, 13, 152, 155, 237]),
  updateMaxPlayers: Buffer.from([174, 195, 93, 246, 110, 89, 112, 238]),
  updateTreasuryWallet: Buffer.from([23, 201, 227, 212, 18, 219, 169, 240]),
  enterArena: Buffer.from([237, 44, 241, 163, 152, 39, 13, 181]),
  setStartPrice: Buffer.from([172, 199, 165, 159, 199, 210, 161, 245]),
  setEndPrice: Buffer.from([53, 149, 82, 113, 237, 242, 171, 28]),
  finalizeArena: Buffer.from([66, 155, 212, 24, 174, 62, 93, 81]),
  claimOwnTokens: Buffer.from([29, 84, 22, 14, 126, 67, 12, 111]),
  claimLoserTokens: Buffer.from([76, 127, 192, 84, 200, 201, 164, 199]),
};

export type InstructionType = keyof typeof INSTRUCTION_DISCRIMINATORS;

/**
 * Identify instruction type from data
 */
export function identifyInstruction(data: Buffer): InstructionType | null {
  if (data.length < 8) return null;

  const discriminator = data.slice(0, 8);

  for (const [name, disc] of Object.entries(INSTRUCTION_DISCRIMINATORS)) {
    if (discriminator.equals(disc)) {
      return name as InstructionType;
    }
  }

  return null;
}

/**
 * Parse enterArena instruction data
 */
export function parseEnterArenaData(data: Buffer): {
  assetIndex: number;
  amount: bigint;
  usdValue: bigint;
} | null {
  if (data.length < 8 + 1 + 8 + 8) return null;

  let offset = 8; // Skip discriminator

  const assetIndex = data.readUInt8(offset);
  offset += 1;

  const amount = data.readBigUInt64LE(offset);
  offset += 8;

  const usdValue = data.readBigUInt64LE(offset);

  return { assetIndex, amount, usdValue };
}

/**
 * Parse setStartPrice instruction data
 */
export function parseSetPriceData(data: Buffer): {
  price: bigint;
} | null {
  if (data.length < 8 + 8) return null;

  const price = data.readBigUInt64LE(8); // Skip discriminator
  return { price };
}

/**
 * Check if a program ID matches our target program
 */
export function isProgramInstruction(programId: PublicKey): boolean {
  return programId.equals(PROGRAM_ID);
}

/**
 * Extract account keys from parsed instruction
 */
export interface InstructionAccounts {
  globalState?: string;
  arena?: string;
  arenaAsset?: string;
  playerEntry?: string;
  player?: string;
  admin?: string;
  winner?: string;
  loserEntry?: string;
}

export function extractAccountsFromInstruction(
  instructionType: InstructionType,
  accountKeys: string[]
): InstructionAccounts {
  const accounts: InstructionAccounts = {};

  switch (instructionType) {
    case 'initialize':
      accounts.globalState = accountKeys[0];
      accounts.admin = accountKeys[1];
      break;

    case 'enterArena':
      accounts.globalState = accountKeys[0];
      accounts.arena = accountKeys[1];
      accounts.arenaAsset = accountKeys[2];
      accounts.playerEntry = accountKeys[3];
      accounts.player = accountKeys[6];
      break;

    case 'setStartPrice':
    case 'setEndPrice':
      accounts.globalState = accountKeys[0];
      accounts.arena = accountKeys[1];
      accounts.arenaAsset = accountKeys[2];
      accounts.admin = accountKeys[3];
      break;

    case 'finalizeArena':
      accounts.globalState = accountKeys[0];
      accounts.arena = accountKeys[1];
      accounts.admin = accountKeys[2];
      break;

    case 'claimOwnTokens':
      accounts.arena = accountKeys[0];
      accounts.playerEntry = accountKeys[1];
      accounts.winner = accountKeys[4];
      break;

    case 'claimLoserTokens':
      accounts.globalState = accountKeys[0];
      accounts.arena = accountKeys[1];
      accounts.arenaAsset = accountKeys[2];
      accounts.playerEntry = accountKeys[3]; // winner entry
      accounts.loserEntry = accountKeys[4];
      accounts.winner = accountKeys[8];
      break;
  }

  return accounts;
}

export default {
  identifyInstruction,
  parseEnterArenaData,
  parseSetPriceData,
  isProgramInstruction,
  extractAccountsFromInstruction,
  INSTRUCTION_DISCRIMINATORS,
};

